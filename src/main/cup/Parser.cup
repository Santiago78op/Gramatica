/*
    Siempre se debe definir el paquete
    en el que se encuentra la clase Lexer,
    esto es importante para que el analizador
    lexico pueda encontrar la clase parser.
*/
package com.julian;

// Cup es la clase que contiene los simbolos que
// se usan en el analizador sintactico.
import java_cup.runtime.*;

/*
    Importamos las clases necesarias para el
    funcionamiento del analizador sintactico.
*/
import java.util.ArrayList;
import java.util.List;

/*
    Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores.
*/
parser code {:

    // Variables para guardar los conjuntos y operaciones
    Object val_0;
    Object val_1;
    Object val_2;
    Object val_3;
    Object val_4;

    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Errores en la entrada");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }

    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        //System.exit(1);
    }

    // Funcion para crear el conjunto Union
    public List<Object> createUnion(List<Object> a, List<Object> b) {
        List<Object> result = new ArrayList<Object>();
        for (Object o : a) {
            if (!result.contains(o)) {
                result.add(o);
            }
        }
        for (Object o : b) {
            if (!result.contains(o)) {
                result.add(o);
            }
        }
        return result;
    }

    // Funcion para crear el conjunto Interseccion
    public List<Object> createInterseccion(List<Object> a, List<Object> b) {
        List<Object> result = new ArrayList<Object>();
        for (Object o : a) {
            if (b.contains(o)) {
                result.add(o);
            }
        }
        return result;
    }

    // Funcion para crear el conjunto Complemento
    public List<Object> createComplemento(List<Object> a, List<Object> b) {
        List<Object> result = new ArrayList<Object>();
        for (Object o : a) {
            if (!b.contains(o)) {
                result.add(o);
            }
        }
        return result;
    }

    // Funcion para crear el conjunto Diferencia
    public List<Object> createDiferencia(List<Object> a, List<Object> b) {
        List<Object> result = new ArrayList<Object>();
        for (Object o : a) {
            if (!b.contains(o)) {
                result.add(o);
            }
        }
        return result;
    }

    // Funcion para evaluar una operacion
    public List<Object> evaluarOperacion(String operacion, List<Object> a, List<Object> b) {
        if (operacion == null || a == null || b == null) {
            throw new IllegalArgumentException("Operation and sets must not be null");
        }
        switch (operacion) {
            case "&":
                return createInterseccion(a, b);
            case "U":
                return createUnion(a, b);
            case "-":
                return createDiferencia(a, b);
            case "~":
                return createComplemento(a, b);
            default:
                return new ArrayList<Object>();
        }
    }

    // Función para evaluar si los elementos están en el conjunto resultante
    public boolean evaluarElementos(List<Object> a, List<Object> b) {
        for (Object o : a) {
            if (!b.contains(o)) {
                return false;
            }
        }
        return true;
    }

:}

/* ------------Declaracion de simbolos terminales y no terminales---------- */

/* Terminales (tokens obtenidos por el analizador lexico).

   Terminales que no tienen un valor son listados primero, los terminales
   que tienen un valor como los enteros son listados en la segunda o demas
   lineas.
*/

// Terminales que no tienen un valor son listados primero.
terminal CONJ, OPERA, EVALUAR, LBRACE, RBRACE, LPAREN, RPAREN,
         ARROW, SEMICOLON, COLON, VIRGULILLA, COMMA, UNION,
         INTERSECCION, COMPLEMENTO, DIFERENCIA, STRING_LITERAL;

// Terminales que tienen un valor como los enteros son listados
// en la segunda o demas lineas.
terminal String ID;
terminal Double NUM;

/* ------------- Sección de no terminales ----------- */

/* No terminales usados en la seccion gramatical.

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a
   que no tienen tipo, pudiendo ser entero o String.
*/

non terminal Object     block, conj_list, conj_part, expr_def, conjunto_expr,
                        oper_list, oper_part, oper_def, oper_expr, eval_list,
                        eval_part, expre_conj, simbol_expr;

/* ------------- Precedencia y Asociatividad de Terminales ----------- */

/*
   La precedencia de los operadores se define aquí.
   Los operadores en las líneas inferiores tienen mayor precedencia
   que los de las líneas superiores.

   precedence left UNION, INTERSECCION;
   precedence left DIFERENCIA, COMPLEMENTO;
*/

precedence left UNION, INTERSECCION;
precedence left DIFERENCIA, COMPLEMENTO;

/* ------------------- Sección de la gramática ------------------------ */

// Inicia la gramática con el símbolo de inicio.
/* Símbolo de inicio */
start with block;

/* ------------------- Sección de la gramática ------------------------ */

/* La gramatica de nuestro analizador sintactico.

   Parte de este ejemplo:
   {
       #Definición de conjuntos
       CONJ : conjuntoA -> 1,2,3,a,b ;
       CONJ : conjuntoB -> a~z;
       CONJ : conjuntoC -> 0~9;

       #Definición de operaciones
       OPERA : operacion1 -> & {conjuntoA} {conjuntoB};
       OPERA : operacion2 -> & U {conjuntoB} {conjuntoC} {conjuntoA};

       #Evaluamos conjuntos de datos
       EVALUAR ( {a, b, c} , operacion1 );
       EVALUAR ( {1, b} , operacion1 );
   }
*/

/* Bloque de definiciones */

/* block es el incio de nuestra gramatica. Puede derivar a
   otra operacion 'conj_list' seguida de 'oper_list' y
   finalziando con 'eval_list'.
*/

block ::= LBRACE
                conj_list
                oper_list
                eval_list
          RBRACE;

/* 'conj_list'  puede derivar a otra 'conj_list' seguida de un
   'conj_part' o puede derivar directamente a un 'conj_part'. */

conj_list ::= conj_list conj_part
               |
               conj_part;

/* La parte 'conj_part' es una combinación de la palabra reservada
   CONJ + COLON seguida del por la definición de un conjunto y
   terminada por el terminal SEMICOLON. El cuerpo de 'expr_def'
   define el nombre del conjunto (ID) y su expresión (conjunto_expr). */

conj_part ::= CONJ COLON expr_def SEMICOLON;

/* 'expr_def' define un conjunto mediante la asignación de un
   identificador (ID) a una expresión de conjunto (conjunto_expr).
   La expresión puede ser una secuencia de números o identificadores
   separados por comas, o un rango definido con el símbolo VIRGULILLA. */

 expr_def ::= ID ARROW conjunto_expr;

 /* 'conjunto_expr' define los elementos del conjunto, que pueden
    ser números, identificadores, o un rango de valores definido por
    el símbolo VIRGULILLA. */

conjunto_expr ::= conjunto_expr COMMA NUM
                {:
                    List<Object> temp = (List<Object>)val_0;
                    if (temp == null) {
                        temp = new ArrayList<>();
                    }
                    temp.add(val_2);
                    RESULT = temp;
                :}
                | conjunto_expr COMMA ID
                {:
                    List<Object> temp = (List<Object>)val_0;
                    if (temp == null) {
                        temp = new ArrayList<>();
                    }
                    temp.add(val_2);
                    RESULT = temp;
                :}
                | NUM
                {:
                    List<Object> temp = new ArrayList<>();
                    temp.add(val_0);
                    RESULT = temp;
                :}
                | ID
                {:
                    List<Object> temp = new ArrayList<>();
                    temp.add(val_0);
                    RESULT = temp;
                :}
                | ID VIRGULILLA ID
                {:
                    List<Object> temp = new ArrayList<>();
                    if (val_0 != null && val_2 != null) {
                        char start = ((String)val_0).charAt(0);
                        char end = ((String)val_2).charAt(0);
                        for (char c = start; c <= end; c++) {
                            temp.add(c);
                        }
                    }
                    RESULT = temp;
                :}
                | NUM VIRGULILLA NUM
                {:
                    List<Object> temp = new ArrayList<>();
                    if (val_0 != null && val_2 != null) {
                        int start = ((Double)val_0).intValue();
                        int end = ((Double)val_2).intValue();
                        for (int i = start; i <= end; i++) {
                            temp.add(i);
                        }
                    }
                    RESULT = temp;
                :};
/* 'oper_list' define la lista de operaciones, que pueden ser
   operaciones de intersección, unión, complemento, o diferencia
   entre conjuntos. Cada operación está seguida por los conjuntos
   involucrados y terminada por SEMICOLON. */

oper_list ::= oper_list oper_part
            |
            oper_part;

/*
    'oper_part' define una operación mediante la asignación de un
    identificador (ID) a una expresión de operación (oper_expr).
    La expresión puede ser una operación de unión, intersección,
    complemento, o diferencia entre conjuntos. */
oper_part ::= OPERA COLON oper_def SEMICOLON;

/* 'oper_def' define una operación mediante la asignación de un
    identificador (ID) a una expresión de operación (oper_expr).
    La expresión puede ser una operación de unión, intersección,
    complemento, o diferencia entre conjuntos. */
oper_def ::= ID ARROW oper_expr expre_conj;

/* 'oper_expr' define las operaciones entre conjuntos, que pueden
    ser operaciones de unión, intersección, complemento, o diferencia
    entre conjuntos. Cada operación está seguida por los conjuntos
    involucrados. */

oper_expr ::= oper_expr simbol_expr
            {:
                RESULT = evaluarOperacion((String)val_1, (List<Object>)val_0, (List<Object>)val_2);
            :}
            | simbol_expr
            {:
                RESULT = (List<Object>)val_0;
            :};

simbol_expr ::= UNION
            {:
                RESULT = "U";
            :}
            | INTERSECCION
            {:
                RESULT = "&";
            :}
            | COMPLEMENTO
            {:
                RESULT = "-";
            :}
            | DIFERENCIA
            {:
                RESULT = "~";
            :};

expre_conj ::= expre_conj LBRACE conjunto_expr RBRACE
            {:
                RESULT = evaluarOperacion((String)val_1, (List<Object>)val_0, (List<Object>)val_2);
            :}
            | LBRACE conjunto_expr RBRACE
            {:
                RESULT = (List<Object>)val_1;
            :};

/*
    'eval_list' define la lista de evaluaciones de conjuntos, que
    pueden ser evaluaciones de conjuntos de datos con operaciones
    de intersección, unión, complemento, o diferencia entre conjuntos.
    Cada evaluación está seguida por los conjuntos de datos y la
    operación involucrada y terminada por SEMICOLON. */

eval_list ::= eval_list eval_part
            |
            eval_part;

/*
    'eval_part' define una evaluación de conjuntos mediante la
    asignación de un identificador (ID) a una expresión de
    evaluación (eval_expr). La expresión puede ser una evaluación
    de conjuntos de datos con operaciones de intersección, unión,
    complemento, o diferencia entre conjuntos. */

eval_part ::= EVALUAR LPAREN LBRACE conjunto_expr RBRACE COMMA ID RPAREN SEMICOLON
            {:
                RESULT = evaluarElementos((List<Object>)val_2, (List<Object>)val_4);
            :};
