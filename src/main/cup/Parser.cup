/*
    Siempre se debe definir el paquete
    en el que se encuentra la clase Lexer,
    esto es importante para que el analizador
    lexico pueda encontrar la clase parser.
*/
package com.julian;

// Cup es la clase que contiene los simbolos que
// se usan en el analizador sintactico.
import java_cup.runtime.*;

/*
    Importamos las clases necesarias para el
    funcionamiento del analizador sintactico.
*/
import java.util.ArrayList;
import java.util.List;

/*
    Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores.
*/
parser code {:

    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Errores en la entrada");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }

    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        //System.exit(1);
    }

:}

/* ------------Declaracion de simbolos terminales y no terminales---------- */

/* Terminales (tokens obtenidos por el analizador lexico).

   Terminales que no tienen un valor son listados primero, los terminales
   que tienen un valor como los enteros son listados en la segunda o demas
   lineas.
*/

// Terminales que no tienen un valor son listados primero.
terminal CONJ, OPERA, EVALUAR, LBRACE, RBRACE, LPAREN, RPAREN,
         ARROW, SEMICOLON, COLON, VIRGULILLA, COMMA, UNION,
         INTERSECCION, COMPLEMENTO, DIFERENCIA, STRING_LITERAL;

// Terminales que tienen un valor como los enteros son listados
// en la segunda o demas lineas.
terminal String ID;
terminal Double NUM;

/* ------------- Sección de no terminales ----------- */

/* No terminales usados en la seccion gramatical.

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a
   que no tienen tipo, pudiendo ser entero o String.
*/

non terminal Tree       B, C, C_LIST, E, EXPR;

/* ------------- Precedencia y Asociatividad de Terminales ----------- */

/*
   La precedencia de los operadores se define aquí.
   Los operadores en las líneas inferiores tienen mayor precedencia
   que los de las líneas superiores.

   precedence left UNION, INTERSECCION;
   precedence left DIFERENCIA, COMPLEMENTO;
*/

precedence left UNION, INTERSECCION;
precedence left DIFERENCIA, COMPLEMENTO;

/* ------------------- Sección de la gramática ------------------------ */

// Inicia la gramática con el símbolo de inicio.
/* Símbolo de inicio */
start with B;

/* ------------------- Sección de la gramática ------------------------ */

/* La gramatica de nuestro analizador sintactico.

   Parte de este ejemplo:
   {
       #Definición de conjuntos
       CONJ : conjuntoA -> 1,2,3,a,b ;
       CONJ : conjuntoB -> a~z;
       CONJ : conjuntoC -> 0~9;

       #Definición de operaciones
       OPERA : operacion1 -> & {conjuntoA} {conjuntoB};
       OPERA : operacion2 -> & U {conjuntoB} {conjuntoC} {conjuntoA};

       #Evaluamos conjuntos de datos
       EVALUAR ( {a, b, c} , operacion1 );
       EVALUAR ( {1, b} , operacion1 );
   }
*/

/* Bloque de definiciones */
B ::= CONJ:conj EXPR:expr SEMICOLON:simicolon
        {:
            Tree b = new Tree("B");
            b.addChildren(new Tree(conj.toString()));
            b.addChildren(expr);
            b.addChildren(new Tree(simicolon.toString()));
            RESULT = b;
        :};

EXPR ::= EXPR:expr1 COMMA:comma NUM:num
        {:
            Tree expr = new Tree("EXPR");
            expr.addChildren(expr1);
            expr.addChildren(new Tree(comma.toString()));
            expr.addChildren(new Tree(num.toString()));
            RESULT = expr;
        :}
        | EXPR:c1 COMMA:comma ID:id
        {:
            Tree expr = new Tree("EXPR");
            expr.addChildren(c1);
            expr.addChildren(new Tree(comma.toString()));
            expr.addChildren(new Tree(id.toString()));
            RESULT = expr;
        :}
        | NUM:num
        {:
            Tree expr = new Tree("EXPR");
            expr.addChildren(new Tree(num.toString()));
            RESULT = expr;
        :}
        | ID:id
        {:
            Tree expr = new Tree("EXPR");
            expr.addChildren(new Tree(id.toString()));
            RESULT = expr;
        :}
        | ID:id_ini VIRGULILLA ID:id_end
        {:
            Tree expr = new Tree("EXPR");
            char start = (id_ini.toString()).charAt(0);
            char end = (id_end.toString()).charAt(0);
            for (char c = start; c <= end; c++) {
                if (c < end){
                    expr.addChildren(new Tree(","));
                }
                expr.addChildren(new Tree(String.valueOf(c)));
            }
            RESULT = expr;
        :}
        | NUM:num_ini VIRGULILLA NUM:num_end
        {:
            Tree expr = new Tree("EXPR");
            char start = (num_ini.toString()).charAt(0);
            char end = (num_end.toString()).charAt(0);
            for (char c = start; c <= end; c++) {
                if (c < end){
                    expr.addChildren(new Tree(","));
                }
                expr.addChildren(new Tree(String.valueOf(c)));
            }
            RESULT = expr;
        :};