 /*
    Siempre se debe definir el paquete
    en el que se encuentra la clase Lexer,
    esto es importante para que el analizador
    lexico pueda encontrar la clase parser.
*/
package com.julian;

// Cup es la clase que contiene los simbolos que
// se usan en el analizador sintactico.
import java_cup.runtime.*;

/*
    Importamos las clases necesarias para el
    funcionamiento del analizador sintactico.
*/
import java.util.ArrayList;
import java.util.List;

/*
    Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores.
*/
parser code {:

    // Lista de errores sintacticos
    public List<SyntaxError> syntaxErrors = new ArrayList<>();

    // Obtiene el estado actual del parser
    public int getCurrentParserState(){
        return ((Symbol) stack.peek()).parse_state;
    }

    // Reporta un error sintactico
    @Override
    public void report_error(String message, Object info) {
        // Obtine el estado actual del parser
        int currentState = getCurrentParserState();

        // Inicialisamos las lineas y columnas
        int line = -1;
        int column = -1;

        String incomingToken = "unknown";

        if (info instanceof Symbol) {
           Symbol s = (Symbol) info;
           if (s.left >= 0) {
               line = s.left + 1;
           }
           if (s.right >= 0) {
               column = s.right + 1;
           }
           incomingToken = s.value.toString();
        }

        // Obtener los tokens esperados
        String expectedTokens = getExpectedTokensForCurrentState(currentState);

        String errorMessage = "Se encontró '" + incomingToken + "' en el estado " + currentState + " y se esperaba " + expectedTokens + ".";
        SyntaxError error = new SyntaxError("Syntax Error", errorMessage, line, column);
        if (!syntaxErrors.contains(error)) {
           syntaxErrors.add(error);
        }
        System.err.println("Error: " + errorMessage);
    }

    // Reporta un error de sintaxis
    private String getExpectedTokensForCurrentState(int currentState) {
        StringBuilder expectedTokens = new StringBuilder();

        // Obtener la tabla de acciones
        short[][] actionTable = action_table();

        int lenthTokens = actionTable.length;
        // Verifica si el elemento actual está dentro del rango de la tabla
        if (currentState >= 0 && currentState <= lenthTokens) {
            short[] actionsForCurrentStates = actionTable[currentState];

            int curr = actionsForCurrentStates.length;
            // Itera sobre los posibles tokens terminales
            for (int i = 0; i < curr; i++){
                int actionLenth = actionsForCurrentStates[i];
                if (actionLenth > 0) {
                    int expectedLength = expectedTokens.length();
                    if (expectedLength > 0) {
                        expectedTokens.append(", ");
                    }
                    if (actionLenth < 21) {
                        expectedTokens.append(sym.terminalNames[actionLenth]);
                    }

                }
            }
        }

        return expectedTokens.toString();
    }

    // Reporta un error de sintaxis
    @Override
    public Symbol parse() {
        try {
            return super.parse();
        } catch (Exception e) {
            System.err.println("Error: Couldn't repair and continue parse");
            // e.printStackTrace();
            return null;
        }
}

:}

/* ------------Declaracion de simbolos terminales y no terminales---------- */

/* Terminales (tokens obtenidos por el analizador lexico).

   Terminales que no tienen un valor son listados primero, los terminales
   que tienen un valor como los enteros son listados en la segunda o demas
   lineas.
*/

// Terminales que tienen un valor como los enteros son listados
// en la segunda o demas lineas.
terminal String ID;
terminal int NUM;
terminal Double DECIMAL;

// Terminales que no tienen un valor son listados primero.
terminal UNION, INTERSECCION, COMPLEMENTO, DIFERENCIA, ARROW, COMMA,
         LPAREN, RPAREN, COLON, SEMICOLON, LBRACE, RBRACE, VIRGULILLA,
         CONJ, OPERA, EVALUAR, CHART;

/* ------------- Sección de no terminales ----------- */

/* No terminales usados en la seccion gramatical.

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a
   que no tienen tipo, pudiendo ser entero o String.
*/

non terminal TreeNode<String> BLOCK, CONJ_LIST, CONJ_PART, EXPR_DEF, CONJUNTO_EXPR,
                              OPER_LIST, OPER_PART, OPER_DEF, OPER_EXPR, EVAL_LIST,
                              EVAL_PART, EXPRE_CONJ, SIMBOL_EXPR, EXPR, CONJ_EXPR;

/* ------------- Precedencia y Asociatividad de Terminales ----------- */

/*
   La precedencia de los operadores se define aquí.
   Los operadores en las líneas inferiores tienen mayor precedencia
   que los de las líneas superiores.

   precedence left UNION, INTERSECCION;
   precedence left DIFERENCIA, COMPLEMENTO;
*/

precedence left UNION, INTERSECCION;
precedence left DIFERENCIA, COMPLEMENTO;

/* ------------------- Sección de la gramática ------------------------ */

// Inicia la gramática con el símbolo de inicio.
/* Símbolo de inicio */
start with BLOCK;

/* ------------------- Sección de la gramática ------------------------ */

/* La gramatica de nuestro analizador sintactico.

   Parte de este ejemplo:
   {
       #Definición de conjuntos
       CONJ : conjuntoA -> 1,2,3,a,b ;
       CONJ : conjuntoB -> a~z;
       CONJ : conjuntoC -> 0~9;

       #Definición de operaciones
       OPERA : operacion1 -> & {conjuntoA} {conjuntoB};
       OPERA : operacion2 -> & U {conjuntoB} {conjuntoC} {conjuntoA};

       #Evaluamos conjuntos de datos
       EVALUAR ( {a, b, c} , operacion1 );
       EVALUAR ( {1, b} , operacion1 );
   }
*/

/* Bloque de definiciones */

/* block es el incio de nuestra gramatica. Puede derivar a
   otra operacion 'conj_list' seguida de 'oper_list' y
   finalziando con 'eval_list'.
*/

BLOCK ::= LBRACE:lbrace
                    CONJ_LIST:conj_list
                    OPER_LIST:oper_list
                    EVAL_LIST:eval_list
             RBRACE:rbrace
{:
    TreeNode<String> blockNode = new TreeNode<>("BLOCK");

    blockNode.addChild(new TreeNode<>(lbrace.toString()));
    blockNode.addChild(conj_list);
    blockNode.addChild(oper_list);
    blockNode.addChild(eval_list);
    blockNode.addChild(new TreeNode<>(rbrace.toString()));

    RESULT = blockNode;
:};

/* 'conj_list'  puede derivar a otra 'conj_list' seguida de un
   'conj_part' o puede derivar directamente a un 'conj_part'. */

CONJ_LIST ::= CONJ_LIST:conj_list CONJ_PART:conj_part
{:
    TreeNode<String> conjListNode = new TreeNode<>("CONJ_LIST");
    conjListNode.addChild(conj_list);
    conjListNode.addChild(conj_part);
    RESULT = conjListNode;
:}
            | CONJ_PART:conj_part
{:
    TreeNode<String> conjListNode = new TreeNode<>("CONJ_LIST");
    conjListNode.addChild(conj_part);
    RESULT = conjListNode;
:};
/* La parte 'conj_part' es una combinación de la palabra reservada
   CONJ + COLON seguida del por la definición de un conjunto y
   terminada por el terminal SEMICOLON. El cuerpo de 'expr_def'
   define el nombre del conjunto (ID) y su expresión (conjunto_expr). */

CONJ_PART ::= CONJ:conj COLON:colon EXPR_DEF:expr_def
                        SEMICOLON:semicolon
{:
    TreeNode<String> conjPartNode = new TreeNode<>("CONJ_PART");
    conjPartNode.addChild(new TreeNode<>(conj.toString()));
    conjPartNode.addChild(new TreeNode<>(colon.toString()));
    conjPartNode.addChild(expr_def);
    conjPartNode.addChild(new TreeNode<>(semicolon.toString()));
    RESULT = conjPartNode;
:};

/* 'expr_def' define un conjunto mediante la asignación de un
   identificador (ID) a una expresión de conjunto (conjunto_expr).
   La expresión puede ser una secuencia de números o identificadores
   separados por comas, o un rango definido con el símbolo VIRGULILLA. */

EXPR_DEF ::= ID:id ARROW:arrow CONJUNTO_EXPR:conjunto_expr
{:
    TreeNode<String> exprDedNode = new TreeNode<>("EXPR_DEF");
    exprDedNode.addChild(new TreeNode<>(id.toString()));
    exprDedNode.addChild(new TreeNode<>(arrow.toString()));
    exprDedNode.addChild(conjunto_expr);
    RESULT = exprDedNode;
:};

/* 'conjunto_expr' define un conjunto mediante la asignación de
   un identificador (ID) a una expresión de conjunto (conjunto_expr).
   La expresión puede ser una secuencia de números o identificadores
   separados por comas, o un rango definido con el símbolo VIRGULILLA. */

CONJUNTO_EXPR ::= CONJUNTO_EXPR:conjunto_expr COMMA:comma EXPR:expr
{:
    TreeNode<String> conjuntoExprNode = new TreeNode<>("CONJUNTO_EXPR");
    conjuntoExprNode.addChild(conjunto_expr);
    conjuntoExprNode.addChild(new TreeNode<>(comma.toString()));
    conjuntoExprNode.addChild(expr);
    RESULT = conjuntoExprNode;
:}
              | EXPR:expr
{:
    TreeNode<String> conjuntoExprNode = new TreeNode<>("CONJUNTO_EXPR");
    conjuntoExprNode.addChild(expr);
    RESULT = conjuntoExprNode;
:};

/* 'expr' define una expresión de conjunto, que puede ser un
   identificador (ID), un número (NUM), un número decimal (DECIMAL),
   o un caracter (CHART). */

EXPR ::=  ID:id      VIRGULILLA:virgulilla  ID:id2
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(id.toString()));
    exprNode.addChild(new TreeNode<>(virgulilla.toString()));
    exprNode.addChild(new TreeNode<>(id2.toString()));
    RESULT = exprNode;
:}
        | NUM:num1  VIRGULILLA:virgulilla NUM:num2
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(Integer.toString(num1)));
    exprNode.addChild(new TreeNode<>(virgulilla.toString()));
    exprNode.addChild(new TreeNode<>(Integer.toString(num2)));
    RESULT = exprNode;
:}
        | DECIMAL:decimal1 VIRGULILLA:virgulilla DECIMAL:decimal2
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(decimal1.toString()));
    exprNode.addChild(new TreeNode<>(virgulilla.toString()));
    exprNode.addChild(new TreeNode<>(decimal2.toString()));
    RESULT = exprNode;
:}
        | CHART:chart   VIRGULILLA:virgulilla NUM:num
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(chart.toString()));
    exprNode.addChild(new TreeNode<>(virgulilla.toString()));
    exprNode.addChild(new TreeNode<>(Integer.toString(num)));
    RESULT = exprNode;
:}
        | NUM:num     VIRGULILLA:virgulilla CHART:chart
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(Integer.toString(num)));
    exprNode.addChild(new TreeNode<>(virgulilla.toString()));
    exprNode.addChild(new TreeNode<>(chart.toString()));
    RESULT = exprNode;
:}
        | CHART:chart1   VIRGULILLA:virgulilla CHART:chart2
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(chart1.toString()));
    exprNode.addChild(new TreeNode<>(virgulilla.toString()));
    exprNode.addChild(new TreeNode<>(chart2.toString()));
    RESULT = exprNode;
:}
        | ID:id
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(id.toString()));
    RESULT = exprNode;
:}
        | NUM:num
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(Integer.toString(num)));
    RESULT = exprNode;
:}
        | DECIMAL:decimal
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(decimal.toString()));
    RESULT = exprNode;
:}
        | CHART:chart
{:
    TreeNode<String> exprNode = new TreeNode<>("EXPR");
    exprNode.addChild(new TreeNode<>(chart.toString()));
    RESULT = exprNode;
:};

/* 'oper_list' define la lista de operaciones, que pueden ser
   operaciones de intersección, unión, complemento, o diferencia
   entre conjuntos. Cada operación está seguida por los conjuntos
   involucrados y terminada por SEMICOLON. */

OPER_LIST ::= OPER_LIST:oper_list OPER_PART:oper_part
{:
    TreeNode<String> operListNode = new TreeNode<>("OPER_LIST");
    operListNode.addChild(oper_list);
    operListNode.addChild(oper_part);
    RESULT = operListNode;
:}
            | OPER_PART:oper_part
{:
    TreeNode<String> operListNode = new TreeNode<>("OPER_LIST");
    operListNode.addChild(oper_part);
    RESULT = operListNode;
:};

/*
    'oper_part' define una operación mediante la asignación de un
    identificador (ID) a una expresión de operación (oper_expr).
    La expresión puede ser una operación de unión, intersección,
    complemento, o diferencia entre conjuntos. */

OPER_PART ::= OPERA:opera COLON:colon ID:id ARROW:arrow CONJ_EXPR:conj_expr
                        SEMICOLON:semicolon
{:
    TreeNode<String> operPartNode = new TreeNode<>("OPER_PART");
    operPartNode.addChild(new TreeNode<>(opera.toString()));
    operPartNode.addChild(new TreeNode<>(colon.toString()));
    operPartNode.addChild(new TreeNode<>(id.toString()));
    operPartNode.addChild(new TreeNode<>(arrow.toString()));
    operPartNode.addChild(conj_expr);
    operPartNode.addChild(new TreeNode<>(semicolon.toString()));
    RESULT = operPartNode;
:};

/* 'conj_expr' define una expresión de operación, que puede ser
    una operación de unión, intersección, complemento, o diferencia
    entre conjuntos. */

CONJ_EXPR ::= CONJ_EXPR:conj_expr OPER_EXPR:oper_expr EXPRE_CONJ:expre_conj
{:
    TreeNode<String> conjExprNode = new TreeNode<>("CONJ_EXPR");
    conjExprNode.addChild(conj_expr);
    conjExprNode.addChild(oper_expr);
    conjExprNode.addChild(expre_conj);
    RESULT = conjExprNode;
:}
            | OPER_EXPR:oper_expr EXPRE_CONJ:expre_conj
{:
    TreeNode<String> conjExprNode = new TreeNode<>("CONJ_EXPR");
    conjExprNode.addChild(oper_expr);
    conjExprNode.addChild(expre_conj);
    RESULT = conjExprNode;
:};

/* 'oper_expr' define las operaciones entre conjuntos, que pueden
    ser operaciones de unión, intersección, complemento, o diferencia
    entre conjuntos. Cada operación está seguida por los conjuntos
    involucrados. */

OPER_EXPR ::= OPER_EXPR:oper_expr SIMBOL_EXPR:simbol_expr
{:
    TreeNode<String> operExprNode = new TreeNode<>("OPER_EXPR");
    operExprNode.addChild(oper_expr);
    operExprNode.addChild(simbol_expr);
    RESULT = operExprNode;
:}
            | SIMBOL_EXPR:simbol_expr
{:
    TreeNode<String> operExprNode = new TreeNode<>("OPER_EXPR");
    operExprNode.addChild(simbol_expr);
    RESULT = operExprNode;
:};

 /* 'simbol_expr' define los simbolos de las operaciones entre conjuntos,
    que pueden ser operaciones de unión, intersección, complemento, o diferencia
    entre conjuntos. */

/* Simbolos de las operaciones entre conjuntos */
SIMBOL_EXPR ::= UNION:union
{:
    TreeNode<String> simbolExprNode = new TreeNode<>("SIMBOL_EXPR");
    simbolExprNode.addChild(new TreeNode<>(union.toString()));
    RESULT = simbolExprNode;
:}
            | INTERSECCION:interseccion
{:
    TreeNode<String> simbolExprNode = new TreeNode<>("SIMBOL_EXPR");
    simbolExprNode.addChild(new TreeNode<>(interseccion.toString()));
    RESULT = simbolExprNode;
:}
            | COMPLEMENTO:complemento
{:
    TreeNode<String> simbolExprNode = new TreeNode<>("SIMBOL_EXPR");
    simbolExprNode.addChild(new TreeNode<>(complemento.toString()));
    RESULT = simbolExprNode;
:}
            | DIFERENCIA:diferencia
{:
    TreeNode<String> simbolExprNode = new TreeNode<>("SIMBOL_EXPR");
    simbolExprNode.addChild(new TreeNode<>(diferencia.toString()));
    RESULT = simbolExprNode;
:};

EXPRE_CONJ ::= EXPRE_CONJ:expre_conj LBRACE:lbrace
                          ID:id RBRACE:rbrace
{:
    TreeNode<String> exprConjNode = new TreeNode<>("EXPRE_CONJ");
    exprConjNode.addChild(expre_conj);
    exprConjNode.addChild(new TreeNode<>(lbrace.toString()));
    exprConjNode.addChild(new TreeNode<>(id.toString()));
    exprConjNode.addChild(new TreeNode<>(rbrace.toString()));
    RESULT = exprConjNode;
:}
            | LBRACE:lbrace ID:id RBRACE:rbrace
{:
    TreeNode<String> exprConjNode = new TreeNode<>("EXPRE_CONJ");
    exprConjNode.addChild(new TreeNode<>(lbrace.toString()));
    exprConjNode.addChild(new TreeNode<>(id.toString()));
    exprConjNode.addChild(new TreeNode<>(rbrace.toString()));
    RESULT = exprConjNode;
:};

/*
    'eval_list' define la lista de evaluaciones de conjuntos, que
    pueden ser evaluaciones de conjuntos de datos con operaciones
    de intersección, unión, complemento, o diferencia entre conjuntos.
    Cada evaluación está seguida por los conjuntos de datos y la
    operación involucrada y terminada por SEMICOLON. */

EVAL_LIST ::= EVAL_LIST:eval_list EVAL_PART:eval_part
{:
    TreeNode<String> evalListNode = new TreeNode<>("EVAL_LIST");
    evalListNode.addChild(eval_list);
    evalListNode.addChild(eval_part);
    RESULT = evalListNode;
:}
            | EVAL_PART:eval_part
{:
    TreeNode<String> evalListNode = new TreeNode<>("EVAL_LIST");
    evalListNode.addChild(eval_part);
    RESULT = evalListNode;
:};

/*
    'eval_part' define una evaluación de conjuntos mediante la
    asignación de un identificador (ID) a una expresión de
    evaluación (eval_expr). La expresión puede ser una evaluación
    de conjuntos de datos con operaciones de intersección, unión,
    complemento, o diferencia entre conjuntos. */

EVAL_PART ::= EVALUAR:evaluar
                LPAREN:lparen
                    LBRACE:lbrace CONJUNTO_EXPR:conjunto_expr
                    RBRACE:rbrace COMMA:comma ID:id
                RPAREN:rparen SEMICOLON:semicolon
{:
    TreeNode<String> evalPartNode = new TreeNode<>("EVAL_PART");
    evalPartNode.addChild(new TreeNode<>(evaluar.toString()));
    evalPartNode.addChild(new TreeNode<>(lparen.toString()));
    evalPartNode.addChild(new TreeNode<>(lbrace.toString()));
    evalPartNode.addChild(conjunto_expr);
    evalPartNode.addChild(new TreeNode<>(rbrace.toString()));
    evalPartNode.addChild(new TreeNode<>(comma.toString()));
    evalPartNode.addChild(new TreeNode<>(id.toString()));
    evalPartNode.addChild(new TreeNode<>(rparen.toString()));
    evalPartNode.addChild(new TreeNode<>(semicolon.toString()));
    RESULT = evalPartNode;
:};