
/*
    Siempre se debe definir el paquete
    en el que se encuentra la clase Lexer,
    esto es importante para que el analizador
    lexico pueda encontrar la clase parser.
*/
package com.julian;

// Cup es la clase que contiene los simbolos que
// se usan en el analizador sintactico.
import java_cup.runtime.*;
/*
    Importamos las clases necesarias para el
    funcionamiento del analizador sintactico.
*/
import java.util.ArrayList;
import java.util.List;

/*
    Codigo del parser, se copia integramente a la clase final.
    Agregamos el manejo de errores.
*/
parser code {:

    /* Reporte de error encontrado. */
    public void report_error(String message, Object info) {
        StringBuilder m = new StringBuilder("Error");
        if (info instanceof java_cup.runtime.Symbol) {
            java_cup.runtime.Symbol s = ((java_cup.runtime.Symbol) info);
            if (s.left >= 0) {
                m.append(" in line "+(s.left+1));
                if (s.right >= 0)
                    m.append(", column "+(s.right+1));
            }
        }
        m.append(" : "+message);
        System.err.println(m);
    }

    /* Cuando se encuentra un error de donde el sistema no puede
        recuperarse, se lanza un error fatal. Se despliega el mensaje
        de error y se finaliza la ejecucion. */
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:}

/* ------------Declaracion de simbolos terminales y no terminales---------- */

/* Terminales (tokens obtenidos por el analizador lexico).

   Terminales que no tienen un valor son listados primero, los terminales
   que tienen un valor como los enteros son listados en la segunda o demas
   lineas.
*/

// Terminales que no tienen un valor son listados primero.
terminal CONJ, OPERA, EVALUAR, LBRACE, RBRACE, LPAREN, RPAREN,
         HASH, LT_EXCL, EXCL_GT, ARROW, SEMICOLON, COLON, VIRGULILLA,
         COMMA, UNION, INTERSECCION, COMPLEMENTO, DIFERENCIA;

// Terminales que tienen un valor como los enteros son listados
// en la segunda o demas lineas.
terminal String ID;
terminal Double NUM;

/* ------------- Sección de no terminales ----------- */

/* No terminales usados en la seccion gramatical.

   Primero se lista los no terminales que tienen un valor Object y despues
   se lista los no terminales que tienen un entero. Un Object se refiere a
   que no tienen tipo, pudiendo ser entero o String.
*/

non terminal Object     conj_list, conj_part, expr_def, conjunto_expr, oper_list,
                        oper_part, oper_def, oper_expr, eval_list, eval_part, block;

/* ------------- Precedencia y Asociatividad de Terminales ----------- */

/*
   La precedencia de los operadores se define aquí.
   Los operadores en las líneas inferiores tienen mayor precedencia
   que los de las líneas superiores.

   precedence left UNION, INTERSECCION;
   precedence left DIFERENCIA, COMPLEMENTO;
*/

precedence left UNION, INTERSECCION;
precedence left DIFERENCIA, COMPLEMENTO;

/* ------------------- Sección de la gramática ------------------------ */

// Inicia la gramática con el símbolo de inicio.
/* Símbolo de inicio */
start with conj_list;

/* ------------------- Sección de la gramática ------------------------ */

/* La gramática para nuestro analizador sintáctico.

   conj_list ::=   conj_list conj_part
                 | conj_part
   conj_part ::=   CONJ expr_def SEMICOLON
   expr_def  ::=   ID ARROW conjunto_expr
   conjunto_expr ::= conjunto_expr COMMA NUM
                   | conjunto_expr COMMA ID
                   | NUM
                   | ID
                   | ID VIRGULILLA ID
*/

/* 'conj_list' es el inicio de nuestra gramática. Puede derivar a
   otra 'conj_list' seguida de un 'conj_part' o puede derivar
   directamente a un 'conj_part'. */

/* La parte 'conj_part' es una combinación de la palabra reservada
   CONJ seguida por la definición de un conjunto y terminada por
   el terminal SEMICOLON. El cuerpo de 'expr_def' define el
   nombre del conjunto (ID) y su expresión (conjunto_expr). */

   conj_list ::= conj_list conj_part
                |
                conj_part;

/* 'expr_def' define un conjunto mediante la asignación de un
   identificador (ID) a una expresión de conjunto (conjunto_expr).
   La expresión puede ser una secuencia de números o identificadores
   separados por comas, o un rango definido con el símbolo VIRGULILLA. */

   conj_part ::= CONJ expr_def SEMICOLON;

   expr_def ::= ID ARROW conjunto_expr;

/* 'conjunto_expr' define los elementos del conjunto, que pueden
   ser números, identificadores, o un rango de valores definido por
   el símbolo VIRGULILLA. */

   conjunto_expr ::= conjunto_expr COMMA NUM
                    | conjunto_expr COMMA ID
                    | NUM
                    | ID
                    | ID VIRGULILLA ID;

/* 'oper_list' define la lista de operaciones, que pueden ser
   operaciones de intersección, unión, complemento, o diferencia
   entre conjuntos. Cada operación está seguida por los conjuntos
   involucrados y terminada por SEMICOLON. */

   oper_list ::= oper_list oper_part
                |
                oper_part;

   oper_part ::= OPERA oper_def SEMICOLON;

   oper_def ::= ID ARROW oper_expr;

   oper_expr ::= OP_UNION conjunto_expr conjunto_expr
               | OP_INTERSECCION conjunto_expr conjunto_expr
               | OP_COMPLEMENTO conjunto_expr
               | OP_DIFERENCIA conjunto_expr conjunto_expr;

/* 'eval_expr' define la evaluación de operaciones sobre
   conjuntos de datos. */

   eval_list ::= eval_list eval_part
               |
               eval_part;

   eval_part ::= EVALUAR LPAREN conjunto_expr COMMA ID RPAREN SEMICOLON;